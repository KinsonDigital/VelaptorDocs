---
sidebar_position: 6
---

import { TutorialLink } from "@site/src/components/TutorialLink";

# Keyboard Input

The wonder of interactivity.  Being able to control your game with a keyboard or other types of hardware input is a must.  Without the ability
to control your game, you are just staring at a looping animation.  The "interface" between the human playing the game
and the game responding to the human is the hardware such as a keyboard or mouse.

Hardware for interacting with games can come in many forms.  The most common is a keyboard, mouse, or game controller.

This guide will show you how to use the keyboard to control your game.  The options for how to respond to keyboard input are
endless. Examples of what you can do with the keyboard are character movement, pausing the game,
and unfortunately, quitting the game.  Most of the time we don't want to quit and just keep playing. üòÅ

:::note project example
Go to the <TutorialLink projectName="KeyboardInput"/> tutorial project to see a fully working example.
:::


## <span class="color-step">Step 1: Project setup</span>

This tutorial will use keyboard input to move the game window around and also change the size of the window.

I know, not very exciting but we want to keep the tutorials as simple as possible so as not to introduce concepts or Velaptor
features that you are not familiar with yet.

Create a basic Velaptor application.
The only game loop methods required for this tutorial will be the `OnUpdate()` and `OnResize()` methods.

:::note REFER TO
For more info, refer to the [Project Setup](./project-setup) guide.  
:::


## <span class="color-step">Step 2: Creating game state</span>

We need to create some class fields to hold onto some state.  Let's do this now.

### <span class="color-sub-step">Step 2.1: Creating the class fields</span>


Create some class fields that will be useful for things such as getting keyboard state, saving keyboard state,
and some variables for holding information for moving the window.

```csharp
public class Game : Window
{
	private const float VelocityXAndY = 300f;
	private readonly IAppInput<KeyboardState> keyboard;
	private KeyboardState currKeyState;
	private KeyboardState prevKeyState;
	private Vector2 velocity = Vector2.Zero;
}
```

### <span class="color-sub-step">Step 2.2: Creating a keyboard object</span>

Create a new instance of `IAppInput<KeyboardState>` which will be used to get the state of the keyboard.  This can easily be done by using
Velaptors handy `InputFactory` class to easily create keyboard objects.  Save this object instance to the class field `keyboard`
in the `Game()` constructor.

```csharp
public Game() => this.keyboard = InputFactory.CreateKeyboard();
```

:::info What is this _**Factory**_ thing?
The Factory pattern is a creational design pattern that provides an interface for creating objects.
Click [here](https://refactoring.guru/design-patterns/factory-method) for a great site about creational patterns.
:::


## <span class="color-step">Step 3: Creating helpful methods</span>

We don't _**NEED**_ these methods that we are about to create.  However, they will make our code more readable and
easier to understand.  This is good practice no matter what kind of software you are writing.

### <span class="color-sub-step">Step 3.1: Key pressed detection</span>

Create a private method in the `Game` class with the name `IsPressed()` which will check if a keyboard key has been pressed.

```csharp
private bool IsPressed(KeyCode key) => this.currKeyState.IsKeyUp(key) &&
										this.prevKeyState.IsKeyDown(key);
```

This method will check if the _**current**_ state of the key is in the up position, and if the state of the same key was in the down
position in the _**previous**_ frame.  If this is the case, then the key was pressed down and then released which means
the key was pressed.

This will make more sense when we create our `Update()` method logic.

### <span class="color-sub-step">Step 3.2: Moving the window</span>

When we press the arrow keys on the keyboard, we want to move the window around.  To do this, create the `MoveWindow()`
below with the following code.

```csharp
private void MoveWindow(FrameTime frameTime)
{
	if (this.currKeyState.IsKeyDown(KeyCode.Right))
	{
		this.velocity.X = VelocityXAndY;
	}

	if (this.currKeyState.IsKeyDown(KeyCode.Left))
	{
		this.velocity.X = -VelocityXAndY; // Negate the velocity to move left
	}

	if (this.currKeyState.IsKeyDown(KeyCode.Up))
	{
		this.velocity.Y = -VelocityXAndY; // Negate the velocity to move up
	}

	if (this.currKeyState.IsKeyDown(KeyCode.Down))
	{
		this.velocity.Y = VelocityXAndY;
	}

	var displacement = this.velocity * (float)frameTime.ElapsedTime.TotalSeconds;

	Position += displacement;
}
```

This method will check if an arrow key is in the down position.  If it is, it will then set the velocity of the `velocity`
field component to a value that will move the window in the direction described by the arrow key.
This will be called later in our `OnUpdate()` method.

:::info How are time, velocity, and displacement related?

<details><summary>Expand me for more info!!</summary>
Why are we multiplying the velocity by the time?  This is because we want to move the window at a constant speed regardless of the
frame rate.  If we didn't multiply the velocity by the time, the faster the CPU, the faster the window would move.
The frame rate is not the same on all computers.  The faster the CPU, the faster the framerate.  Basically, it is all
about movement over time!

<br/>
<br/>

**Example:** If you moved the window 10 pixels every frame and the frame rate was 60 frames per second, then the window would
move 600 pixels per second.  Now let's say that the window moved 10 pixels every frame and the frame rate was 30 frames per second.
The window would move 300 pixels per second.  As you can see, the window would move at a different speed on a slow CPU
vs a fast CPU.  This is not what we want.  Games need to be consistent and game objects need to move at the same speed
on all computers, regardless of the CPU speed.
</details>
::: 

### <span class="color-sub-step">Step 3.3: Changing the window size</span>

The window size will be changed when we press the arrow keys.  Create the `ChangeWinSize()` method with the code below
to change the size of the window using the keyboard.

```csharp
private void ChangeWinSize()
{
	if (IsPressed(KeyCode.Right))
	{
		Width += 50; // Increase the width of the window
	}

	if (IsPressed(KeyCode.Left))
	{
		Width -= 50; // Decrease the width of the window
	}

	if (IsPressed(KeyCode.Up))
	{
		Height -= 50; // Decrease the height of the window
	}

	if (IsPressed(KeyCode.Down))
	{
		Height += 50; // Increase the height of the window
	}
}
```

This method checks if the arrow keys have been pressed fully down and then released.  If they have, then the size of
the window will be changed.  This will also be called later in our `OnUpdate()` method.


## <span class="color-step">Step 4: Finish up</span>

We can now finish up the rest by tracking the state of the keyboard and using some simple logic to move or resize
the window based on the state of the keyboard keys.

### <span class="color-sub-step">Step 4.1: Getting the keyboard state</span>

When you want to be able to check the state of the keyboard keys, you need to get the state of the entire
keyboard during the _**current**_ frame of the game loop, and for every frame of the game loop.  Once you have the state of
the keyboard, you can analyze which keys are in the up or down position.  With this information, you can make decisions
about what to do when a single key or combination of key(s) is in the up or down position.

First, set the _**current**_ and _**previous**_ state of the keyboard.

```csharp
protected override void OnUpdate(FrameTime frameTime)
{
	this.currKeyState = this.keyboard.GetState();
	this.prevKeyState = this.currKeyState;
}
```

To accurately detect keyboard input, we need to get and save both the _**current**_ and _**previous**_ states. This helps us
track changes in key states, such as when a key is pressed down and then released, which is necessary for
accurate detection of a _**full**_ key press.

### <span class="color-sub-step">Step 4.2: Putting it all together</span>

In between the _**current**_ and _**previous**_ keyboard state lines of code, add the logic to the `OnUpdate()` method below:

```csharp
protected override void OnUpdate(FrameTime frameTime)
{
	...
	// If the left or right control key is pressed, move the window.
	if (this.currKeyState.AnyCtrlKeysDown())
	{
		MoveWindow(frameTime);
	}
	else
	{
		// Change the window size.
		ChangeWinSize();
	}

	this.velocity = Vector2.Zero;
	...
}
```

The `OnUpdate()` method will first check if the _**current**_ state of any _**Ctrl**_ keys is being pressed in the down position.
If this is the case, then the window will be moved.  If not, then the window size will be changed.

### <span class="color-sub-step">Step 4.3: Run It</span>

Run the application to see it in action!!  First, only press the _**arrow keys**_ and you will see the width and height
of the window increase and decrease in size.  Notice that the size will not change unless you lift your fingers off
of the arrow keys from the down position.

Now press and hold down any _**Ctrl**_ key and then press the _**arrow keys**_.  You will see the window move around
the screen.  Notice, that you do not have to lift your finger off the arrow keys to continue to move the window.
This is because we are not looking for a _**full**_ key press of the arrow keys.
