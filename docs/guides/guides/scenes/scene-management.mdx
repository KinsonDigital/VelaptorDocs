---
sidebar_position: 8
---

import TutorialLink from "@site/src/components/TutorialLink";
import ImageLink from "@site/src/components/ImageLink";
import GitHubImg from "@site/src/components/GitHubImg";
import GuideImg from "@site/src/components/GuideImg";
import GuideAudio from "@site/src/components/GuideAudio";
import Url from "@site/src/components/Url";
import GitHubDownloadImg from "./images/github-download.png";

# Scenes Management

:::note Guide Source Code
Go to the following links to see the source code for fully working examples of managed and unmanaged scenes.

- <TutorialLink projectName="ManagedScenes" version="v1.0.0-preview.35"/>
- <TutorialLink projectName="UnmanagedScenes" version="v1.0.0-preview.35"/>
:::

When it comes to games, how you manage your scenes can impact many aspects of your game. It can improve performance by only loading what
is necessary for that section of your game, keep your code organized, and make it easier to debug, and more. In this guide, we will cover how to manage
scenes in your game.

_**Velaptor**_ comes with its own scene manager.  This scene manager performs various common tasks for you like loading and unloading,
auto-updating, rendering, and behavior of how you transition between scenes.  But you also do not have to use the built in
scene manager!  If you want more control, you can also build your own scene manager.  _**Velaptor**_ does not stand in your way!

:::note ABOUT THIS GUIDE
This guide will not show you how to manage scenes yourself.  That is a more advanced topic.  If you are interested
in how it works, _**Velaptor**_ is open source!!  You can see how we built the scene manager and see how it works by looking at the source code.
:::


Let's start by creating our first scene.

## <span className="color-step">Step 1: Project setup</span>

Before we start, make sure you have a basic project set up.


### <span className="color-sub-step">Step 1.1: Setup project</span>

To get started, create a new _**Velaptor**_ application.
:::note Refer To Guide

For more info, refer to the [Project Setup](../project-setup) guide.
:::

### <span className="color-sub-step">Step 1.2: Add content</span>

By following the [Adding Content](../adding-content) guide, add the content below to your project.
Just click the images below to download them, and click the three dots on the audio player to download it.

<div className="flex flex-row items-center">
    <div className="w-1/3">
        <GuideImg className="justify-self-end"
                apiVersion="v1.0.0-preview.35"
                guideName="ManagedScenes"
                imgFileName="kd-logo.png"
                sizePercentage={50}
                useTestMode="true"
                testBranchOrTag="feature/226-create-scene-guide"/>
    </div>

    <div className="w-1/3">
        <GuideImg className="justify-self-start"
                apiVersion="v1.0.0-preview.35"
                guideName="ManagedScenes"
                imgFileName="velaptor-mascot.png"
                sizePercentage={55}
                useTestMode="true"
                testBranchOrTag="feature/226-create-scene-guide"/>
    </div>

    <div className="w-1/3">
        <GuideAudio apiVersion="v1.0.0-preview.35"
                    guideName="ManagedScenes"
                    name="Mario Jump"
                    audioFileName="mario-jump.ogg"
                    useTestMode="true"
                    testBranchOrTag="feature/226-create-scene-guide"/>
    </div>
</div>

<br/>

:::note WANT TO USE YOUR OWN CONTENT?

When clicking the images above, click the GitHub download button shown below.

<img src={GitHubDownloadImg} width={20 + "%"}/>

Absolutely!  Feel free to use any content you want.

Remember, the content has to be a `.png` file for images and a `.mp3` or `.ogg` file for audio.
:::

## <span className="color-step">Step 2: Create Scene A</span>

We will be creating two scenes.  One will be named `SceneA` and the other will be named `SceneB`.  If we want to demonstrate how to navigate
between scenes, we need more than one scene.  We will create `SceneA` first.

### <span className="color-sub-step">Step 2.1: Create the class</span>

Scenes have various lifecycle methods that we can take advantage of just like with the `Window` class.  These methods
are automatically called by the scene manager to load and unload content, update the scene, and render the scene.

Create a new class named `SceneA` and inherit from the `abstract` `SceneBase` class.

```csharp showLineNumbers showLineNumbers
public class SceneA : SceneBase
{
}
```

### <span className="color-sub-step">Step 2.2: Create override methods</span>

Now, we can take advantage of the lifecycle methods by overriding some of them.  Create the following methods in the
`SceneA` class.

```csharp showLineNumbers
public class SceneA : SceneBase
{
    // highlight-add-start
    public override void LoadContent()
    {
        // You load content in here
        base.LoadContent();
    }

    public override void UnloadContent()
    {
        // You unload content in here
        base.UnloadContent();
    }

    public override void Update(FrameTime frameTime)
    {
        // You update the scene here
        base.Update(frameTime);
    }

    public override void Render()
    {
        // You render the scene here
        base.Render();
    }
    // highlight-add-end
}
```

### <span className="color-sub-step">Step 2.3: Create loaders and renderers</span>

We cannot load, use, render, and unload our scene content without our loaders and renderers.
We need to create the loaders and renderers as class fields so they can be used through the lifetime
of the scene to load and render the content.

#### <span className="color-sub-step-item">Step 2.3a: Create class fields</span>

```csharp showLineNumbers
public class SceneA: SceneBase
{
    // highlight-add-start
    private readonly ILoader<ITexture> textureLoader;
    private readonly ILoader<IFont> fontLoader; // Used to load the font to for rendering the instructions
    private readonly ITextureRenderer textureRenderer;
    private readonly IFontRenderer fontRenderer; // Used to render the instructions
    // highlight-add-end
    ...
}
```

#### <span className="color-sub-step-item">Step 2.3b: Set loaders and renderers</span>

```csharp showLineNumbers
// highlight-add-start
public SceneA()
{
    this.textureLoader = ContentLoaderFactory.CreateTextureLoader();
    this.fontLoader = ContentLoaderFactory.CreateFontLoader();

    this.textureRenderer = RendererFactory.CreateTextureRenderer();
    this.fontRenderer = RendererFactory.CreateFontRenderer();
}
// highlight-add-end
```

### <span className="color-sub-step">Step 2.4: Load the scene content</span>

Now that we have a way to load content, we can use the loaders to load the content.

#### <span className="color-sub-step-item">Step 2.4a: Texture and font class fields</span>

Add the following class fields to hold the texture and font.

```csharp showLineNumbers
public class SceneA : SceneBase
{
    private readonly ILoader<ITexture> textureLoader;
    private readonly ILoader<IFont> fontLoader; // Used to load the font to for rendering the instructions
    private readonly ITextureRenderer textureRenderer;
    private readonly IFontRenderer fontRenderer; // Used to render the instructions
    // highlight-add-start
    private ITexture? logoTexture;
    private IFont? font;
    // highlight-add-end
    ...
}
```

#### <span className="color-sub-step-item">Step 2.4b: Load the content</span>

Now we can load the content in the `LoadContent()` method.  Use the loaders to load the texture and font.

```csharp showLineNumbers
public override void LoadContent()
{
    // highlight-add-start
    this.logoTexture = this.textureLoader.Load("kd-logo");
    this.font = this.fontLoader.Load("TimesNewRoman-Regular", 12);
    // highlight-add-end
    base.LoadContent();
}
```

:::tip Content Reminder
Remember, if you have decided to use your content, make sure that the name of the content being loaded
matches the name of your content file without the extension.
:::

### <span className="color-sub-step">Step 2.5: Unloading the content</span>

Depending on your game, you may or may not need to unload the content.  In most cases, if you move to another scene,
you do not need to the content anymore. To free up resources, you can unload the content in the `UnloadContent` method.

To do this, use the loaders to unload your content in the `UnloadContent` method as shown below.

```csharp showLineNumbers
public override void UnloadContent()
{
    // highlight-add-start
    this.textureLoader.Unload(this.logoTexture);
    this.fontLoader.Unload(this.font);
    // highlight-add-end
    base.UnloadContent();
}
```

### <span className="color-sub-step">Step 2.6: Add something interesting</span>

To add something interesting in the scene to see the `Update` and `Render` methods in action, we can use the mouse input
to be able to have the texture follow the mouse as you move it around the screen.

Create some class fields to get the state of the mouse and remember the position of the mouse.
We will use the `IAppInput<MouseState> mouse` field to get the state of the mouse on every frame.

```csharp showLineNumbers
public class SceneA : SceneBase
{
    private readonly ILoader<ITexture> textureLoader;
    private readonly ILoader<IFont> fontLoader; // Used to load the font to for rendering the instructions
    private readonly ITextureRenderer textureRenderer;
    private readonly IFontRenderer fontRenderer; // Used to render the instructions
    // highlight-add-next-line
    private readonly IAppInput<MouseState> mouse;
    private ITexture? logoTexture;
    // highlight-add-next-line
    private PointF logoPosition;
    private IFont? font;
}
```

#### <span className="color-sub-step-item">Step 2.6a: Create mouse object</span>

Go into the constructor and use the `HardwareFactory` to set the mouse input class field.

```csharp showLineNumbers
public SceneA()
{
    this.textureLoader = ContentLoaderFactory.CreateTextureLoader();
    this.fontLoader = ContentLoaderFactory.CreateFontLoader();

    this.textureRenderer = RendererFactory.CreateTextureRenderer();
    this.fontRenderer = RendererFactory.CreateFontRenderer();

    // highlight-add-next-line
    this.mouse = HardwareFactory.GetMouse();
}
```

#### <span className="color-sub-step-item">Step 2.6b: Setting mouse position</span>

Awesome!!  Now that we have a way to get the state of the mouse.  We can now go into the `Update()` method and add some
code to get the current position of the mouse.

```csharp showLineNumbers
public override void Update(FrameTime frameTime)
{
    // highlight-add-start
    var currentMouseState = this.mouse.GetState();
    this.logoPosition = mouseState.GetPosition();
    // highlight-add-end
    
    base.Update(frameTime);
}
```

Almost there!!

The final piece is to render the texture at the mouse's position on every frame.  When you move the mouse,
the position of the mouse is remembered and then used to render the texture at that position.

:::tip INVOKE ORDER REMINDER
Remember, most game frameworks and engines, the `Update()` is called first, and then the `Render()` is called.
This is no different in _**Velaptor**_.
The `Update()` method will be called in the same frame as the `Render()` method.
:::

#### <span className="color-sub-step-item">Step 2.6c: Render the texture</span>

Add the following code to the `Render()` method.

```csharp showLineNumbers
public override void Render()
{
    // highlight-add-start
    // Convert the `PointF` to a `Vector2`
    var logoPos = new Vector2(this.logoPosition.X, this.logoPosition.Y);

    // Render the image
    this.textureRenderer.Render(this.logoTexture, logoPos);

    // Render the text
    this.fontRenderer.Render(this.font, Instructions, new Vector2(WindowWidth / 2f, 20));
    // highlight-add-end

    base.Render();
}
```

### <span className="color-sub-step">Step 2.7: A little extra safety</span>

To add some extra safety, we can check if the content was loaded before using it.  Not only does this satisfy
any warnings for null references, but it will also verify that we remembered to load the content.  If we did not
load the content, we would get a null reference exception, and then we could fix the problem.

Add the following null check code to the beginning of the `Render()` method.
    
```csharp showLineNumbers
public override void Render()
{
    // highlight-add-start
    ArgumentNullException.ThrowIfNull(this.logoTexture);
    ArgumentNullException.ThrowIfNull(this.font);
    // highlight-add-end

    // Convert the `PointF` to a `Vector2`
    var logoPos = new Vector2(this.logoPosition.X, this.logoPosition.Y);

    // Render the image
    this.textureRenderer.Render(this.logoTexture, logoPos);

    base.Render();
}
```

### <span className="color-sub-step">Step 2.8: Add some instructions</span>

Next, we will add some simple instructions to the scene.  This will be some text that will be rendered at the top
of the scene to let the user know what to do.

#### <span className="color-sub-step-item">Step 2.8a: Add constants</span>

Add some class field constants to hold the width of the window as well as the instruction text.

```csharp showLineNumbers
public class SceneA : SceneBase
{
    // highlight-add-start
    private const int WindowWidth = 1000;
    private const string Instructions = "Left & right arrow keys to move to scenes.";
    // highlight-add-end
    private readonly ILoader<ITexture> textureLoader;
    private readonly ILoader<IFont> fontLoader; // Used to load the font to for rendering the instructions
    private readonly ITextureRenderer textureRenderer;
    private readonly IFontRenderer fontRenderer; // Used to render the instructions
    private readonly IAppInput<MouseState> mouse;
    private ITexture? logoTexture;
    private PointF logoPosition;
    private IFont? font;
}
```

#### <span className="color-sub-step-item">Step 2.8b: Render the instructions</span>

Now just add some code to render the instructions at the top of the scene.

```csharp showLineNumbers
public override void Render()
{
    ArgumentNullException.ThrowIfNull(this.logoTexture);
    ArgumentNullException.ThrowIfNull(this.font);

    // Convert the `PointF` to a `Vector2`
    var logoPos = new Vector2(this.logoPosition.X, this.logoPosition.Y);

    // Render the image
    this.textureRenderer.Render(this.logoTexture, logoPos);

    // Render the text
    this.fontRenderer.Render(this.font, Instructions, new Vector2(WindowWidth / 2f, 20));

    base.Render();
}
```

That is it for the first scene!!. We have created our first scene!! Now we can move on to creating the second scene so we can
demonstrate how to navigate from scene to scene.

## <span className="color-step">Step 3: Create Scene B</span>

The second scene is almost identical to the first.  The only difference will be the image used, the instruction text, and
the mouse behavior used.  For the behavior, instead of the image following the mouse, we will simply set the image
to the position of where the mouse is clicked and then play a sound.

### <span className="color-sub-step">Step 3.1: Copy the other scene</span>

To make things easier, since `SceneB` will be almost identical to `SceneA`, copy the `SceneA` class and rename it to `SceneB`.
Also, rename the constructor from `SceneA` to `SceneB`.
Once this is done, we will go through and make the necessary changes.  Do not worry, we will show what should be removed
and what should be added.

### <span className="color-sub-step">Step 3.2: Add class fields</span>

Here we will add some additional class fields.  These fields will be used to
load and hold audio content to be used to make a sound every time the user clicks
the mouse button, and update the instructions.

```csharp showLineNumbers
public class SceneB : SceneBase
{
    private const int WindowWidth = 1000;
    // highlight-add-next-line
    private const int WindowHeight = 1000;
    private const string Instructions = "Left & right arrow keys to move to scenes.\nClick anywhere in the window.";
    private readonly ILoader<ITexture> textureLoader;
    // highlight-add-next-line
    private readonly ILoader<IFont> fontLoader;
    private readonly ILoader<IAudio> audioLoader;
    private readonly ITextureRenderer textureRenderer;
    private readonly IFontRenderer fontRenderer;
    private readonly IAppInput<MouseState> mouse;
    private ITexture? logoTexture;
    private PointF logoPosition;
    private IFont? font;
    // highlight-add-start
    private IAudio? audio;
    private MouseState prevMouseState;
    // highlight-add-end
    ...
}
```

### <span className="color-sub-step">Step 3.3: Create audio loader</span>

This scene uses audio as part of the behavior as explained before.  This means we need to create
an audio loader.

```csharp showLineNumbers
public SceneB()
{
    this.textureLoader = ContentLoaderFactory.CreateTextureLoader();
    this.fontLoader = ContentLoaderFactory.CreateFontLoader();
    // highlight-add-next-line
    this.audioLoader = ContentLoaderFactory.CreateAudioLoader();

    this.textureRenderer = RendererFactory.CreateTextureRenderer();
    this.fontRenderer = RendererFactory.CreateFontRenderer();

    this.mouse = HardwareFactory.GetMouse();
}
```

### <span className="color-sub-step">Step 3.4: Update load content</span>

With the additional audio loader, we can now update our `LoadContent()` method to load the audio content.
In addition, the position of the texture will be set when the user click the mouse. Set a default
starting position for the texture in the center of the window.  We also cannot forget to change which texture is being loaded.

```csharp showLineNumbers
public override void LoadContent()
{
    // highlight-remove-next-line
    this.logoTexture = this.textureLoader.Load("kd-logo");
    // highlight-add-next-line
    this.logoTexture = this.textureLoader.Load("velaptor-mascot");
    this.font = this.fontLoader.Load("TimesNewRoman-Regular", 12);
    // highlight-add-start
    this.audio = this.audioLoader.Load("mario-jump", AudioBuffer.Full);

    // Set the default location of the texture to the center of the window
    this.logoPosition = new Point(WindowWidth / 2, WindowHeight / 2);
    // highlight-add-end

    base.LoadContent();
}
```

### <span className="color-sub-step">Step 3.5: Update unload content</span>

These scene has an additional type of content that needs to be unloaded.  Update the `UnloadContent()` method to
unload the audio content.

```csharp showLineNumbers
public override void UnloadContent()
{
    this.textureLoader.Unload(this.logoTexture);
    this.fontLoader.Unload(this.font);
    // highlight-add-next-line
    this.audioLoader.Unload(this.audio);

    base.UnloadContent();
}
```

### <span className="color-sub-step">Step 3.6: Change behavior</span>

The largest change in `SceneB` is the behavior.  Instead of the texture following the mouse, the texture will be set to the
position of where the mouse is clicked.  When the mouse is clicked, we will play a sound.

```csharp showLineNumbers
public override void Update(FrameTime frameTime)
{
    // highlight-remove-start
    var currentMouseState = this.mouse.GetState();
    this.logoPosition = currentMouseState.GetPosition();
    // highlight-remove-end

    // highlight-add-start
    ArgumentNullException.ThrowIfNull(this.audio);

    var currentMouseState = this.mouse.GetState();

    // If the left mouse button was fully clicked
    if (currentMouseState.IsLeftButtonUp() && this.prevMouseState.IsLeftButtonDown())
    {
        this.audio.Play();
        this.logoPosition = currentMouseState.GetPosition();
    }

    this.prevMouseState = currentMouseState;
    // highlight-add-end
    base.Update(frameTime);
}
```

### <span className="color-sub-step">Step 3.7: Adjust text position</span>

We will update the `Render()` method so that way the instructions are rendered so we can see them.
Since `SceneB` has larger instruction text, we need to position the text farther down the screen
so it is not cut off at the top of the window.

```csharp showLineNumbers
public override void Render()
{
    ArgumentNullException.ThrowIfNull(this.logoTexture);
    ArgumentNullException.ThrowIfNull(this.font);

    // Convert the `PointF` to a `Vector2`
    var logoPos = new Vector2(this.logoPosition.X, this.logoPosition.Y);

    // Render the image
    this.textureRenderer.Render(this.logoTexture, logoPos);

    // Render the text
    // highlight-remove-next-line
    this.fontRenderer.Render(this.font, Instructions, new Vector2(WindowWidth / 2f, 20));
    // highlight-add-next-line
    this.fontRenderer.Render(this.font, Instructions, new Vector2(WindowWidth / 2f, 30));

    base.Render();
}
```

## <span className="color-step">Step 4: Managed Scenes</span>

So now we have two scenes to work with. Each scene does something a little different so that way we can see the difference
between the scenes as we navigate between them.  But what is the point of multiple scenes if you can't get to them?

Let's get into it!!


There are two ways to manage scenes.  You can either use the built-in scene manager or you can manage the scenes yourself.
Why would you want to manage the scenes yourself?  Well, you may want more control over how the scenes are managed.  Maybe
during the time of developing your game, the built in scene manager does not have a particular feature you need.

This is software.  Flexibility is important for many kinds of software, but in games it is even more important.

### <span className="color-sub-step">Step 4.1: Update the game class</span>

So far we have created the scenes, but we have not created out game class yet.  In the game class, this is where you will
instantiate the scenes and add them to the manager.

In step [Step 1.1](./scene-management.mdx#step-11-setup-project), you should of already created the class.

In the code shown below, set the title of the tile and size of the window.

```csharp showLineNumbers
public Game()
{
    // highlight-add-start
    Title = "Managed Scenes";
    Width = 1000;
    Height = 1000;
    // highlight-add-end
}
```

### <span className="color-sub-step">Step 4.2: Keyboard scene navigation</span>

We will be using the arrow keyboard keys to navigate between the scenes.  This is something you should be familiar with.

#### <span className="color-sub-step-item">Step 4.2a: Keyboard input fields</span>

Add the 2 class fields and create a keyboard object.

```csharp showLineNumbers
public class Game : Window
{
    // highlight-add-start
    private readonly IAppInput<KeyboardState> keyboard;
    private KeyboardState prevKeyState;
    // highlight-add-end
    ...
}
```

#### <span className="color-sub-step">Step 4.2b: Create keyboard input object</span>

In the constructor, create the keyboard object.

```csharp showLineNumbers
public Game()
{
    Title = "Managed Scenes";
    Width = 1000;
    Height = 1000;

    // highlight-add-next-line
    this.keyboard = HardwareFactory.GetKeyboard();
}
```

### <span className="color-sub-step">Step 4.3: Create scenes</span>

Now we can create instances of the scenes we created earlier in the guide and add them to the scene manager.

#### <span className="color-sub-step-item">Step 4.3a: Create scene instances</span>

```csharp showLineNumbers
public Game()
{
    Title = "Managed Scenes";
    Width = 1000;
    Height = 1000;

    this.keyboard = HardwareFactory.GetKeyboard();

    // highlight-add-start
    var sceneA = new SceneA { Name = "Scene A", };
    var sceneB = new SceneB { Name = "Scene B", };
    // highlight-add-end
}
```

#### <span className="color-sub-step-item">Step 4.3b: Add scenes to the manager</span>

```csharp showLineNumbers
public Game()
{
    Title = "Managed Scenes";
    Width = 1000;
    Height = 1000;

    this.keyboard = HardwareFactory.GetKeyboard();

    var sceneA = new SceneA { Name = "Scene A", };
    var sceneB = new SceneB { Name = "Scene B", };

    // highlight-add-start
    SceneManager.AddScene(sceneA, setToActive: true);
    SceneManager.AddScene(sceneB);
    // highlight-add-end
}
```

### <span className="color-sub-step">Step 4.4: Scene navigation behavior</span>

Now all we need now is to add some logic to the `Update()` method to navigate between the scenes when the user
presses the left or right arrow keys.

```csharp showLineNumbers
protected override void OnUpdate(FrameTime frameTime)
{
    // highlight-add-start
    var currentKeyState = this.keyboard.GetState();

    // If the user has pressed the left or right arrow keys
    if (currentKeyState.IsKeyDown(KeyCode.Right) && this.prevKeyState.IsKeyUp(KeyCode.Right))
    {
        SceneManager.NextScene();
    }
    else if (currentKeyState.IsKeyDown(KeyCode.Left) && this.prevKeyState.IsKeyUp(KeyCode.Left))
    {
        SceneManager.PreviousScene();
    }

    this.prevKeyState = currentKeyState;
    base.OnUpdate(frameTime);
    // highlight-add-end
}
```

That is it!!  You have created a game with two scenes and you can navigate between them using the arrow keys.
As you can see, the code for managing the scenes is straight forward and minimal.  All of the scene content loading and unloading,
updating, and rendering is handled by the scene manager.
